<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScoreSpotter v1 - Film Score Spotting App</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a1e;
            --bg-panel: #252529;
            --bg-input: #2d2d32;
            --bg-row-white: #2a2a2e;
            --bg-row-gray: #262628;
            --bg-active: #3a4a5a;
            --bg-active-static: #3a4a5a;
            --bg-error: #4a2a2a;
            --text-primary: #e8e8ec;
            --text-secondary: #a0a0a8;
            --text-dim: #707078;
            --accent-blue: #4a7ccc;
            --accent-green: #4a9c6c;
            --reel-blue: #3a5a8c;
            --reel-green: #3a7c5c;
            --border-color: #3a3a3e;
            --error-pink: #cc6a7a;
            --timer-glow: rgba(74, 124, 204, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header Metadata - Matching Spreadsheet Layout */
        .header-metadata {
            background: var(--bg-panel);
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .header-top-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: start;
            margin-bottom: 12px;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .header-center {
            text-align: center;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            gap: 4px;
            text-align: right;
        }

        .film-title-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            background: transparent;
            border: none;
            color: var(--text-primary);
            text-align: center;
            width: 100%;
            outline: none;
        }

        .film-title-input:focus {
            background: var(--bg-input);
            border-radius: 4px;
        }

        .header-field {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .header-field.right {
            justify-content: flex-end;
        }

        .header-label {
            color: var(--text-dim);
            min-width: fit-content;
        }

        .header-input {
            background: transparent;
            border: none;
            border-bottom: 1px solid transparent;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.8rem;
            padding: 2px 4px;
            outline: none;
        }

        .header-input:hover {
            border-bottom-color: var(--border-color);
        }

        .header-input:focus {
            background: var(--bg-input);
            border-radius: 2px;
            border-bottom-color: var(--accent-blue);
        }

        .header-input.wide {
            width: 200px;
        }

        .header-input.medium {
            width: 150px;
        }

        .header-input.narrow {
            width: 100px;
        }

        .header-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        .fps-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 180px);
            min-height: 400px;
        }

        /* Entry Table */
        .entry-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .table-header {
            display: grid;
            grid-template-columns: 12px 70px 120px 90px 200px 1fr 100px;
            gap: 8px;
            padding: 12px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-dim);
            flex-shrink: 0;
        }

        .entries-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            padding-bottom: 300px;
            scroll-behavior: smooth;
        }

        .entry-row {
            display: grid;
            grid-template-columns: 12px 70px 120px 90px 200px 1fr 100px;
            gap: 8px;
            padding: 10px 16px;
            align-items: center;
            transition: background 0.15s;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }

        .entry-row:hover {
            background: var(--bg-active) !important;
        }

        .entry-row.selected {
            background: var(--bg-active-static) !important;
            outline: 2px solid var(--accent-blue);
            outline-offset: -2px;
        }

        .entry-row.pulsing {
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { background: var(--bg-active-static); }
            50% { background: rgba(74, 124, 204, 0.35); }
        }

        .entry-row.error {
            background: var(--bg-error) !important;
        }

        .reel-bar {
            width: 8px;
            height: 100%;
            min-height: 36px;
            border-radius: 2px;
        }

        .reel-bar.blue { background: var(--reel-blue); }
        .reel-bar.green { background: var(--reel-green); }

        .cue-number {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--accent-blue);
        }

        .timecode-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .timecode-edit-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .timecode-edit-field {
            width: 28px;
            background: var(--bg-input);
            border: 1px solid var(--accent-blue);
            border-radius: 3px;
            padding: 4px 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-align: center;
        }

        .timecode-edit-sep {
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .action-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-badge.cue-start { background: #2a4a3a; color: #6acc8a; }
        .action-badge.cue-end { background: #4a2a3a; color: #cc6a8a; }
        .action-badge.blank { background: transparent; color: transparent; min-width: 0; padding: 0; }
        .action-badge.shift { background: #3a3a4a; color: #8a8acc; }
        .action-badge.highlight { background: #4a4a2a; color: #cccc6a; }
        .action-badge.sting { background: #4a3a2a; color: #ccaa6a; }
        .action-badge.xfade { background: #3a2a4a; color: #aa6acc; }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .tag {
            background: var(--accent-blue);
            color: white;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .notes-cell {
            font-size: 0.875rem;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-height: 24px;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: text;
        }

        .notes-cell:hover {
            background: var(--bg-input);
        }

        .notes-input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--accent-blue);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.875rem;
            padding: 4px 8px;
            outline: none;
        }

        .duration-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .duration-display.final {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Right Panel */
        .right-panel {
            width: 300px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
            max-height: 100%;
        }

        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .panel-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-blue);
            padding-bottom: 6px;
            margin-bottom: 4px;
            border-bottom: 1px solid var(--border-color);
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            padding: 3px 0;
        }

        .shortcut-key {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-input);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--accent-blue);
            border: 1px solid var(--border-color);
        }

        .shortcut-label {
            color: var(--text-secondary);
        }

        .theme-entry {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 4px 0;
        }

        .theme-delete-btn {
            width: 24px;
            height: 24px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .theme-delete-btn:hover {
            background: var(--bg-error);
            border-color: var(--error-pink);
            color: var(--error-pink);
        }

        .theme-usage-count {
            min-width: 22px;
            height: 22px;
            background: var(--bg-input);
            border-radius: 11px;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        .theme-key-input {
            width: 40px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-align: center;
            text-transform: uppercase;
        }

        .theme-key-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .theme-meaning-input {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.8rem;
        }

        .theme-meaning-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Floating Timer */
        .floating-timer {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            cursor: move;
            z-index: 1000;
            user-select: none;
            -webkit-user-select: none;
        }

        .floating-timer * {
            user-select: none;
            -webkit-user-select: none;
        }

        .floating-timer input,
        .floating-timer select {
            user-select: text;
            -webkit-user-select: text;
        }

        .floating-timer.playing {
            box-shadow: 0 8px 32px var(--timer-glow), 0 0 60px var(--timer-glow);
            border-color: var(--accent-blue);
        }

        .timer-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 4rem;
            font-weight: 700;
            text-align: center;
            letter-spacing: 3px;
            margin-bottom: 8px;
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-display.playing {
            color: var(--accent-blue);
        }

        .timer-status {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-status.playing {
            color: var(--accent-blue);
        }

        .timer-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px 24px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-grid-cell {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .timer-settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            user-select: none;
            -webkit-user-select: none;
        }
            border-top: 1px solid var(--border-color);
        }

        .timer-setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .timer-setting-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .timer-unit {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-left: 4px;
        }

        .timer-hint {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-left: 6px;
        }

        .timer-select {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.75rem;
        }

        .timer-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .timecode-input-group {
            display: flex;
            gap: 2px;
            align-items: center;
        }

        .timecode-field {
            width: 28px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-align: center;
        }

        .timecode-field:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .timecode-separator {
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .reaction-time-field {
            width: 55px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-align: center;
        }

        .reaction-time-field:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 8px 0;
            z-index: 2000;
            min-width: 220px;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--bg-active);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
            font-size: 0.875rem;
        }

        .toast.error {
            border-color: var(--error-pink);
            color: var(--error-pink);
        }

        .toast.info {
            border-color: var(--accent-blue);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Save/Export Buttons */
        .save-export-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            padding: 12px 24px;
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .save-export-buttons {
            display: flex;
            gap: 12px;
        }

        .copyright-notice {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .copyright-notice a {
            color: var(--text-dim);
            text-decoration: none;
        }

        .copyright-notice a:hover {
            color: var(--text-primary);
            text-decoration: underline;
        }

        .btn {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-active);
            border-color: var(--accent-blue);
        }

        .btn-primary {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .btn-primary:hover {
            background: #5a8cdc;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            font-size: 0.9rem;
            gap: 12px;
        }

        .empty-state-icon {
            font-size: 4rem;
            opacity: 0.3;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .modal-body {
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-danger {
            background: #8a3a3a;
            border-color: #8a3a3a;
            color: white;
        }

        .btn-danger:hover {
            background: #aa4a4a;
            border-color: #aa4a4a;
        }

        .btn-secondary {
            background: #4a5a6a;
            border-color: #4a5a6a;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6a7a;
            border-color: #5a6a7a;
        }
    </style>
</head>
<body>
    <!-- Header Metadata - Matching Spreadsheet Layout -->
    <div class="header-metadata">
        <div class="header-top-row">
            <div class="header-left">
                <div class="header-field">
                    <span class="header-label">Director:</span>
                    <input type="text" class="header-input wide" id="director" placeholder="Name">
                </div>
                <div class="header-field">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="directorContact" placeholder="email / phone">
                </div>
                <div class="header-field" style="margin-top: 8px;">
                    <span class="header-label">Composer:</span>
                    <input type="text" class="header-input wide" id="composer" placeholder="Name">
                </div>
                <div class="header-field">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="composerContact" placeholder="email / phone">
                </div>
            </div>
            <div class="header-center">
                <input type="text" class="film-title-input" id="filmTitle" placeholder="FILM TITLE">
                <div class="header-field" style="justify-content: center; margin-top: 4px;">
                    <input type="text" class="header-input medium" id="version" placeholder="(version)" style="text-align: center;">
                </div>
                <div class="header-field" style="justify-content: center; margin-top: 4px;">
                    <span class="header-label">Picture Date:</span>
                    <input type="date" class="header-input narrow" id="pictureDate">
                </div>
            </div>
            <div class="header-right">
                <div class="header-field right">
                    <span class="header-label">Session Date:</span>
                    <input type="date" class="header-input narrow" id="sessionDate">
                </div>
                <div class="header-field right">
                    <span class="header-label">Producers:</span>
                    <input type="text" class="header-input wide" id="producers" placeholder="Names">
                </div>
                <div class="header-field right">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="producersContact" placeholder="email / phone">
                </div>
                <div class="header-field right" style="margin-top: 8px;">
                    <span class="header-label">Exec Prod:</span>
                    <input type="text" class="header-input wide" id="execProducers" placeholder="Names">
                </div>
                <div class="header-field right">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="execProducersContact" placeholder="email / phone">
                </div>
            </div>
        </div>
        <div class="header-bottom-row">
            <div class="fps-display" id="fpsDisplay">FPS: 24</div>
        </div>
    </div>

    <!-- Floating Timer -->
    <div class="floating-timer" id="floatingTimer">
        <div class="timer-display" id="timerDisplay">01:00:00:00</div>
        <div class="timer-status" id="timerStatus">STOPPED</div>
        <div class="timer-settings-grid">
            <div class="timer-grid-cell">
                <span class="timer-setting-label">FPS</span>
                <select class="timer-select" id="fpsSelect">
                    <optgroup label="Film">
                        <option value="23.976">23.976 fps</option>
                        <option value="24" selected>24 fps</option>
                    </optgroup>
                    <optgroup label="PAL/European">
                        <option value="25">25 fps</option>
                    </optgroup>
                    <optgroup label="NTSC/North American">
                        <option value="29.97ndf">29.97 fps NDF</option>
                        <option value="29.97df">29.97 fps DF</option>
                        <option value="30">30 fps</option>
                    </optgroup>
                    <optgroup label="High Frame Rate">
                        <option value="48">48 fps</option>
                        <option value="50">50 fps</option>
                        <option value="59.94ndf">59.94 fps NDF</option>
                        <option value="59.94df">59.94 fps DF</option>
                        <option value="60">60 fps</option>
                    </optgroup>
                </select>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Offset</span>
                <div class="timecode-input-group">
                    <input type="text" class="timecode-field" id="offsetHH" value="01" maxlength="2">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="offsetMM" value="00" maxlength="2">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="offsetSS" value="00" maxlength="2">
                    <span class="timecode-separator" id="offsetFrameSep">:</span>
                    <input type="text" class="timecode-field" id="offsetFF" value="00" maxlength="2">
                </div>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Jump</span>
                <div class="timecode-input-group">
                    <input type="text" class="timecode-field" id="jumpHH" value="" maxlength="2" placeholder="HH">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="jumpMM" value="" maxlength="2" placeholder="MM">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="jumpSS" value="" maxlength="2" placeholder="SS">
                    <span class="timecode-separator" id="jumpFrameSep">:</span>
                    <input type="text" class="timecode-field" id="jumpFF" value="" maxlength="2" placeholder="FF">
                    <button class="btn" id="jumpBtn" style="padding: 4px 8px; font-size: 0.7rem; margin-left: 4px;">GO</button>
                </div>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Reaction Buffer</span>
                <div class="timecode-input-group" style="align-items: center;">
                    <input type="number" class="reaction-time-field" id="reactionTime" value="2.0" step="0.1" min="0" max="10">
                    <span class="timer-unit">sec</span>
                    <span class="timer-hint">(press <strong>-</strong>)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Entry Section -->
        <div class="entry-section">
            <div class="table-header">
                <div></div>
                <div>Cue</div>
                <div>Timecode</div>
                <div>Action</div>
                <div>Tags</div>
                <div>Notes</div>
                <div>Duration</div>
            </div>
            <div class="entries-container" id="entriesContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">üé¨</div>
                    <div>Press <strong>‚Üí</strong> to start the timer</div>
                    <div>Press <strong>1-5</strong> or <strong>0</strong> to add cue markers</div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-section-title">Timer Controls</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">‚Üí</span>
                    <span class="shortcut-label">Start / Stop</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">‚áß + ‚Üê</span>
                    <span class="shortcut-label">Reset (when stopped)</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Action Keys</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">1</span>
                    <span class="shortcut-label">Cue Start</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">2</span>
                    <span class="shortcut-label">(blank timestamp)</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">3</span>
                    <span class="shortcut-label">Shift</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">4</span>
                    <span class="shortcut-label">Highlight</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">5</span>
                    <span class="shortcut-label">Sting</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">6</span>
                    <span class="shortcut-label">Xfade</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Esc</span>
                    <span class="shortcut-label">Cue End</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Other Controls</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">-</span>
                    <span class="shortcut-label">Subtract Reaction Time</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">\</span>
                    <span class="shortcut-label">Next Reel</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Del</span>
                    <span class="shortcut-label">Remove Last Action</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Tab</span>
                    <span class="shortcut-label">Move Between Fields</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Enter</span>
                    <span class="shortcut-label">Confirm Note</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">`</span>
                    <span class="shortcut-label">Deselect Entry</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Thematic Tags</div>
                <div id="themeEntriesContainer">
                    <div class="theme-entry">
                        <input type="text" class="theme-key-input" maxlength="1" placeholder="Key">
                        <input type="text" class="theme-meaning-input" placeholder="Meaning">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Save/Export Bar -->
    <div class="save-export-bar">
        <div class="copyright-notice">
            ¬©2025 Silverphonic SoundLab &nbsp;¬∑&nbsp; <a href="mailto:info@silverphonic.com">info@silverphonic.com</a> &nbsp;¬∑&nbsp; <a href="https://silverphonic.com" target="_blank">Silverphonic.com</a>
        </div>
        <div class="save-export-buttons">
            <button class="btn btn-danger" id="newSessionBtn">New Session</button>
            <button class="btn" id="downloadSessionBtn">Download Session</button>
            <button class="btn" id="loadSessionBtn">Load Session</button>
            <button class="btn" id="exportCsvBtn">Export CSV</button>
            <button class="btn btn-primary" id="exportXlsxBtn">Export Excel</button>
            <input type="file" id="loadSessionInput" accept=".json" style="display: none;">
        </div>
    </div>
    
    <!-- New Session Confirmation Modal -->
    <div class="modal-overlay" id="newSessionModal">
        <div class="modal">
            <div class="modal-title">Start New Session?</div>
            <div class="modal-body">
                This will clear all cue entries. Would you like to save your work first?
            </div>
            <div class="modal-buttons" style="flex-direction: column; gap: 8px;">
                <div style="display: flex; gap: 8px; justify-content: flex-end; width: 100%;">
                    <button class="btn" id="modalCancelBtn">Cancel</button>
                    <button class="btn" id="modalDownloadBtn">Download First</button>
                    <button class="btn" id="modalExportBtn">Export Excel First</button>
                </div>
                <div style="display: flex; gap: 8px; justify-content: flex-end; width: 100%; border-top: 1px solid var(--border-color); padding-top: 12px; margin-top: 4px;">
                    <button class="btn btn-secondary" id="modalKeepInfoBtn" title="Keep project info and thematic tags">New Session (Keep Project Info)</button>
                    <button class="btn btn-danger" id="modalClearBtn">Clear Everything</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="delete-renumber">Delete and Renumber</div>
        <div class="context-menu-item" data-action="delete-keep">Delete Without Renumbering</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="insert-before">Insert Entry Before</div>
        <div class="context-menu-item" data-action="insert-after">Insert Entry After</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="set-reel-renumber">Set Reel Number (Renumber Subsequent)</div>
        <div class="context-menu-item" data-action="set-reel-keep">Set Reel Number (Keep Subsequent)</div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ==================== STATE ====================
        const state = {
            entries: [],
            themes: {},
            metadata: {},
            timer: {
                isPlaying: false,
                currentFrames: 0,
                offsetFrames: 0,
                fps: 24,
                isDropFrame: false,
                startTime: null,
                animationFrame: null
            },
            currentReel: 1,
            currentCueInReel: 0,
            selectedEntryIndex: null,
            lastCueStartIndex: null,
            contextMenuEntryIndex: null,
            actionHistory: [],
            isEditingNotes: false,
            isEditingTimecode: false
        };

        // ==================== FRAME RATE HELPERS ====================
        function getFpsValue(fpsString) {
            const map = {
                '23.976': 23.976,
                '24': 24,
                '25': 25,
                '29.97ndf': 29.97,
                '29.97df': 29.97,
                '30': 30,
                '48': 48,
                '50': 50,
                '59.94ndf': 59.94,
                '59.94df': 59.94,
                '60': 60
            };
            return map[fpsString] || 24;
        }

        function isDropFrame(fpsString) {
            return fpsString.includes('df') && !fpsString.includes('ndf');
        }

        function getMaxFrames() {
            return Math.floor(state.timer.fps);
        }

        function roundToValidFrame(frame) {
            const maxFrame = getMaxFrames() - 1;
            if (frame < 0) {
                showToast(`Frame rounded to 0`, 'info');
                return 0;
            }
            if (frame > maxFrame) {
                showToast(`Frame ${frame} rounded to ${maxFrame}`, 'info');
                return maxFrame;
            }
            return Math.round(frame);
        }

        // ==================== TIMECODE CONVERSION ====================
        function framesToTimecode(totalFrames) {
            const fps = Math.round(state.timer.fps);
            const isDF = state.timer.isDropFrame;
            
            let frames = Math.max(0, Math.floor(totalFrames));
            
            if (isDF && (fps === 30 || fps === 60)) {
                const dropFrames = fps === 60 ? 4 : 2;
                const framesPerMin = fps * 60 - dropFrames;
                const framesPer10Min = fps * 60 * 10 - dropFrames * 9;
                
                const d = Math.floor(frames / framesPer10Min);
                const m = frames % framesPer10Min;
                
                if (m < dropFrames) {
                    frames = frames + dropFrames * d;
                } else {
                    frames = frames + dropFrames * d + dropFrames * Math.floor((m - dropFrames) / framesPerMin);
                }
            }
            
            const ff = frames % fps;
            const totalSeconds = Math.floor(frames / fps);
            const ss = totalSeconds % 60;
            const totalMinutes = Math.floor(totalSeconds / 60);
            const mm = totalMinutes % 60;
            const hh = Math.floor(totalMinutes / 60);
            
            const sep = isDF ? ';' : ':';
            
            return {
                display: `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}${sep}${String(Math.floor(ff)).padStart(2, '0')}`,
                hh, mm, ss, ff: Math.floor(ff)
            };
        }

        function timecodeToFrames(hh, mm, ss, ff) {
            const fps = Math.round(state.timer.fps);
            const isDF = state.timer.isDropFrame;
            
            let totalFrames = hh * 3600 * fps + mm * 60 * fps + ss * fps + ff;
            
            if (isDF && (fps === 30 || fps === 60)) {
                const dropFrames = fps === 60 ? 4 : 2;
                const totalMinutes = hh * 60 + mm;
                const droppedFrames = dropFrames * (totalMinutes - Math.floor(totalMinutes / 10));
                totalFrames -= droppedFrames;
            }
            
            return Math.max(0, totalFrames);
        }

        // ==================== TIMER ====================
        function updateTimerDisplay() {
            const tc = framesToTimecode(state.timer.currentFrames);
            document.getElementById('timerDisplay').textContent = tc.display;
        }

        function startTimer() {
            if (state.timer.isPlaying) return;
            
            state.timer.isPlaying = true;
            state.timer.startTime = performance.now() - (state.timer.currentFrames / state.timer.fps * 1000);
            
            document.getElementById('timerDisplay').classList.add('playing');
            document.getElementById('timerStatus').textContent = 'PLAYING';
            document.getElementById('timerStatus').classList.add('playing');
            document.getElementById('floatingTimer').classList.add('playing');
            
            function tick() {
                if (!state.timer.isPlaying) return;
                
                const elapsed = performance.now() - state.timer.startTime;
                state.timer.currentFrames = Math.floor(elapsed / 1000 * state.timer.fps);
                updateTimerDisplay();
                
                state.timer.animationFrame = requestAnimationFrame(tick);
            }
            
            tick();
        }

        function stopTimer() {
            state.timer.isPlaying = false;
            
            if (state.timer.animationFrame) {
                cancelAnimationFrame(state.timer.animationFrame);
            }
            
            document.getElementById('timerDisplay').classList.remove('playing');
            document.getElementById('timerStatus').textContent = 'STOPPED';
            document.getElementById('timerStatus').classList.remove('playing');
            document.getElementById('floatingTimer').classList.remove('playing');
        }

        function toggleTimer() {
            if (state.timer.isPlaying) {
                stopTimer();
            } else {
                startTimer();
            }
        }

        function resetTimer() {
            if (state.timer.isPlaying) return;
            
            const offsetHH = parseInt(document.getElementById('offsetHH').value) || 0;
            const offsetMM = parseInt(document.getElementById('offsetMM').value) || 0;
            const offsetSS = parseInt(document.getElementById('offsetSS').value) || 0;
            const offsetFF = roundToValidFrame(parseInt(document.getElementById('offsetFF').value) || 0);
            
            state.timer.currentFrames = timecodeToFrames(offsetHH, offsetMM, offsetSS, offsetFF);
            state.timer.offsetFrames = state.timer.currentFrames;
            updateTimerDisplay();
            showToast('Timer reset to offset', 'info');
        }

        function jumpToTime() {
            const hh = parseInt(document.getElementById('jumpHH').value) || 0;
            const mm = parseInt(document.getElementById('jumpMM').value) || 0;
            const ss = parseInt(document.getElementById('jumpSS').value) || 0;
            const ff = roundToValidFrame(parseInt(document.getElementById('jumpFF').value) || 0);
            
            const wasPlaying = state.timer.isPlaying;
            if (wasPlaying) stopTimer();
            
            state.timer.currentFrames = timecodeToFrames(hh, mm, ss, ff);
            updateTimerDisplay();
            
            if (wasPlaying) startTimer();
            
            showToast(`Jumped to ${framesToTimecode(state.timer.currentFrames).display}`, 'info');
        }

        // ==================== ENTRIES ====================
        function getActionName(actionKey) {
            const actions = {
                '1': 'Cue Start',
                '2': '',  // Blank timestamp - no text
                '3': 'Shift',
                '4': 'Highlight',
                '5': 'Sting',
                '6': 'Xfade',
                '0': 'Cue End'
            };
            return actions[actionKey] !== undefined ? actions[actionKey] : '';
        }

        function getActionClass(actionKey) {
            const classes = {
                '1': 'cue-start',
                '2': 'blank',
                '3': 'shift',
                '4': 'highlight',
                '5': 'sting',
                '6': 'xfade',
                '0': 'cue-end'
            };
            return classes[actionKey] || '';
        }

        function findLastCueStart(beforeIndex) {
            // Find the most recent Cue Start OR Xfade (both start cues)
            for (let i = beforeIndex - 1; i >= 0; i--) {
                if (state.entries[i].action === '1' || state.entries[i].action === '6') {
                    return i;
                }
            }
            return null;
        }

        function calculateDuration(entryIndex) {
            const entry = state.entries[entryIndex];
            // Cue Start and Xfade both show 00:00:00:00 (they're the start of a cue)
            if (entry.action === '1' || entry.action === '6') {
                return framesToTimecode(0).display;
            }
            
            const lastStart = findLastCueStart(entryIndex);
            if (lastStart === null) {
                return '--:--:--:--';
            }
            
            const durationFrames = entry.frames - state.entries[lastStart].frames;
            return framesToTimecode(Math.max(0, durationFrames)).display;
        }

        function getCueNumber(entryIndex) {
            const entry = state.entries[entryIndex];
            // Both Cue Start and Xfade get cue numbers (they both start cues)
            if (entry.action !== '1' && entry.action !== '6') return '';
            return `${entry.reel}m${entry.cueNum}`;
        }

        function getReelColor(reel) {
            return reel % 2 === 1 ? 'blue' : 'green';
        }

        function getCueGroupIndex(entryIndex) {
            let group = 0;
            for (let i = 0; i <= entryIndex; i++) {
                // Both Cue Start and Xfade start new cue groups
                if (state.entries[i].action === '1' || state.entries[i].action === '6') {
                    group++;
                }
            }
            return group;
        }

        function addEntry(actionKey) {
            const currentFrames = state.timer.currentFrames;
            const cueIsActive = state.lastCueStartIndex !== null;
            
            // === CUE END (0/Esc) - requires active cue ===
            if (actionKey === '0') {
                if (!cueIsActive) {
                    playErrorSound();
                    showToast('No active cue to end - press 1 for Cue Start first', 'error');
                    return;
                }
                // Just end the cue
                const entry = {
                    frames: currentFrames,
                    action: '0',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.lastCueStartIndex = null;
                state.selectedEntryIndex = state.entries.length - 1;
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === XFADE (6) - requires active cue, auto-inserts Cue End before ===
            else if (actionKey === '6') {
                if (!cueIsActive) {
                    playErrorSound();
                    showToast('No active cue to crossfade from - press 1 for Cue Start first', 'error');
                    return;
                }
                // Insert Cue End one frame before
                const autoEndEntry = {
                    frames: Math.max(0, currentFrames - 1),
                    action: '0',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(autoEndEntry);
                showToast(`Previous cue ended at ${framesToTimecode(currentFrames - 1).display}`, 'info');
                
                // Now add Xfade which starts a new cue
                state.currentCueInReel++;
                const entry = {
                    frames: currentFrames,
                    action: '6',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: state.currentCueInReel
                };
                state.entries.push(entry);
                state.lastCueStartIndex = state.entries.length - 1;
                state.selectedEntryIndex = state.entries.length - 1;
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === CUE START (1) - if cue active, auto-inserts Cue End before ===
            else if (actionKey === '1') {
                if (cueIsActive) {
                    // Insert Cue End one frame before
                    const autoEndEntry = {
                        frames: Math.max(0, currentFrames - 1),
                        action: '0',
                        tags: [],
                        notes: '',
                        reel: state.currentReel,
                        cueNum: null
                    };
                    state.entries.push(autoEndEntry);
                    showToast(`Previous cue ended at ${framesToTimecode(currentFrames - 1).display}`, 'info');
                }
                // Start new cue
                state.currentCueInReel++;
                const entry = {
                    frames: currentFrames,
                    action: '1',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: state.currentCueInReel
                };
                state.entries.push(entry);
                state.lastCueStartIndex = state.entries.length - 1;
                state.selectedEntryIndex = state.entries.length - 1;
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === SHIFT (3), HIGHLIGHT (4), or STING (5) - if no cue, auto-inserts Cue Start before ===
            else if (actionKey === '3' || actionKey === '4' || actionKey === '5') {
                if (!cueIsActive) {
                    // Insert Cue Start one frame before
                    state.currentCueInReel++;
                    const autoStartEntry = {
                        frames: Math.max(0, currentFrames - 1),
                        action: '1',
                        tags: [],
                        notes: '',
                        reel: state.currentReel,
                        cueNum: state.currentCueInReel
                    };
                    state.entries.push(autoStartEntry);
                    state.lastCueStartIndex = state.entries.length - 1;
                    showToast(`Cue auto-started at ${framesToTimecode(currentFrames - 1).display}`, 'info');
                }
                // Now add the Shift, Highlight, or Sting
                const entry = {
                    frames: currentFrames,
                    action: actionKey,
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.selectedEntryIndex = state.entries.length - 1;
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === BLANK TIMESTAMP (2) - just a timestamp, no action text ===
            else if (actionKey === '2') {
                const entry = {
                    frames: currentFrames,
                    action: '2', // Will display as blank
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.selectedEntryIndex = state.entries.length - 1;
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            renderEntries();
            scrollToEntry(state.selectedEntryIndex);
            autoSave();
        }

        function addTagToEntry(key, entryIndex = null) {
            const index = entryIndex !== null ? entryIndex : state.selectedEntryIndex;
            if (index === null) return;
            
            const theme = state.themes[key.toLowerCase()];
            if (!theme) {
                showToast(`No theme defined for key "${key.toUpperCase()}"`, 'info');
                return;
            }
            
            const entry = state.entries[index];
            if (!entry.tags.includes(theme)) {
                entry.tags.push(theme);
                state.actionHistory.push({ type: 'tag', index: index, tag: theme });
                renderEntries();
                autoSave();
            }
        }

        function removeLastAction() {
            if (state.actionHistory.length === 0) return;
            
            const lastAction = state.actionHistory.pop();
            
            if (lastAction.type === 'entry') {
                const removed = state.entries.pop();
                // If we removed a Cue Start or Xfade, decrement the cue counter
                if (removed.action === '1' || removed.action === '6') {
                    state.currentCueInReel--;
                }
                // Recalculate the cue state from scratch
                recalculateCueState();
                state.selectedEntryIndex = state.entries.length > 0 ? state.entries.length - 1 : null;
            } else if (lastAction.type === 'tag') {
                const entry = state.entries[lastAction.index];
                const tagIndex = entry.tags.indexOf(lastAction.tag);
                if (tagIndex > -1) {
                    entry.tags.splice(tagIndex, 1);
                }
            } else if (lastAction.type === 'note') {
                const entry = state.entries[lastAction.index];
                entry.notes = lastAction.previousNote || '';
            }
            
            renderEntries();
            autoSave();
            showToast('Last action removed', 'info');
        }

        function nextReel() {
            state.currentReel++;
            state.currentCueInReel = 0;
            showToast(`Now on Reel ${state.currentReel}`, 'info');
        }

        // ==================== RENDERING ====================
        function renderEntries() {
            const container = document.getElementById('entriesContainer');
            
            if (state.entries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé¨</div>
                        <div>Press <strong>‚Üí</strong> to start the timer</div>
                        <div>Press <strong>1-6</strong> or <strong>Esc</strong> to add cue markers</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            state.entries.forEach((entry, index) => {
                const cueGroup = getCueGroupIndex(index);
                const bgColor = cueGroup % 2 === 0 ? 'var(--bg-row-gray)' : 'var(--bg-row-white)';
                const reelColor = getReelColor(entry.reel);
                const isSelected = index === state.selectedEntryIndex;
                const isPulsing = isSelected && state.timer.isPlaying;
                const tc = framesToTimecode(entry.frames);
                
                const isFinalDuration = entry.action === '0';  // Only Cue End is final, not Xfade
                
                html += `
                    <div class="entry-row ${isSelected ? (isPulsing ? 'pulsing' : 'selected') : ''}" 
                         data-index="${index}"
                         style="background: ${isSelected ? 'var(--bg-active-static)' : bgColor};">
                        <div class="reel-bar ${reelColor}"></div>
                        <div class="cue-number">${getCueNumber(index)}</div>
                        <div class="timecode-display" data-field="timecode">${tc.display}</div>
                        <div class="action-cell"><span class="action-badge ${getActionClass(entry.action)}">${getActionName(entry.action)}</span></div>
                        <div class="tags-container">
                            ${entry.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                        <div class="notes-cell" data-field="notes">${entry.notes || '<span style="color: var(--text-dim); font-style: italic;">Click to add note...</span>'}</div>
                        <div class="duration-display ${isFinalDuration ? 'final' : ''}">${calculateDuration(index)}</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Add click handlers
            container.querySelectorAll('.entry-row').forEach(row => {
                row.addEventListener('click', (e) => {
                    const index = parseInt(row.dataset.index);
                    const field = e.target.closest('[data-field]');
                    
                    if (field && field.dataset.field === 'notes') {
                        e.stopPropagation();
                        makeNotesEditable(index);
                    } else if (field && field.dataset.field === 'timecode') {
                        e.stopPropagation();
                        state.selectedEntryIndex = index;
                        renderEntries();
                        makeTimecodeEditable(index);
                    } else {
                        state.selectedEntryIndex = index;
                        renderEntries();
                    }
                });
                
                row.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    state.contextMenuEntryIndex = parseInt(row.dataset.index);
                    showContextMenu(e.clientX, e.clientY);
                });
            });
            
            // Update tag usage counts in theme panel
            updateThemeUsageCounts();
        }
        
        function updateThemeUsageCounts() {
            const countElements = document.querySelectorAll('.theme-usage-count');
            countElements.forEach(el => {
                const entry = el.closest('.theme-entry');
                if (entry) {
                    const key = entry.dataset.key;
                    if (key && state.themes[key]) {
                        const count = getTagUsageCount(state.themes[key]);
                        el.textContent = count;
                    }
                }
            });
        }

        function makeNotesEditable(index) {
            state.isEditingNotes = true;
            const row = document.querySelector(`.entry-row[data-index="${index}"]`);
            const notesDiv = row.querySelector('.notes-cell');
            const currentNotes = state.entries[index].notes || '';
            
            notesDiv.innerHTML = `<input type="text" class="notes-input" value="${currentNotes}" placeholder="Type note and press Enter...">`;
            const input = notesDiv.querySelector('input');
            input.focus();
            input.select();
            
            const saveNotes = () => {
                const previousNote = state.entries[index].notes;
                state.entries[index].notes = input.value;
                if (input.value !== previousNote) {
                    state.actionHistory.push({ type: 'note', index, previousNote });
                }
                state.isEditingNotes = false;
                renderEntries();
                autoSave();
            };
            
            input.addEventListener('blur', saveNotes);
            input.addEventListener('keydown', (e) => {
                e.stopPropagation();
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    state.isEditingNotes = false;
                    renderEntries();
                }
            });
        }

        function makeTimecodeEditable(index) {
            state.isEditingTimecode = true;
            const row = document.querySelector(`.entry-row[data-index="${index}"]`);
            const tcDiv = row.querySelector('.timecode-display');
            const tc = framesToTimecode(state.entries[index].frames);
            const sep = state.timer.isDropFrame ? ';' : ':';
            
            tcDiv.innerHTML = `
                <div class="timecode-edit-group">
                    <input type="text" class="timecode-edit-field" value="${String(tc.hh).padStart(2, '0')}" maxlength="2" data-tc="hh">
                    <span class="timecode-edit-sep">:</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.mm).padStart(2, '0')}" maxlength="2" data-tc="mm">
                    <span class="timecode-edit-sep">:</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.ss).padStart(2, '0')}" maxlength="2" data-tc="ss">
                    <span class="timecode-edit-sep">${sep}</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.ff).padStart(2, '0')}" maxlength="2" data-tc="ff">
                </div>
            `;
            
            const inputs = tcDiv.querySelectorAll('input');
            inputs[0].focus();
            inputs[0].select();
            
            const saveTimecode = () => {
                const hh = parseInt(tcDiv.querySelector('[data-tc="hh"]').value) || 0;
                const mm = parseInt(tcDiv.querySelector('[data-tc="mm"]').value) || 0;
                const ss = parseInt(tcDiv.querySelector('[data-tc="ss"]').value) || 0;
                const ff = roundToValidFrame(parseInt(tcDiv.querySelector('[data-tc="ff"]').value) || 0);
                
                state.entries[index].frames = timecodeToFrames(hh, mm, ss, ff);
                
                // Re-sort entries by timecode
                state.entries.sort((a, b) => a.frames - b.frames);
                state.selectedEntryIndex = state.entries.findIndex(e => e === state.entries[index]);
                
                recalculateCueState();
                state.isEditingTimecode = false;
                renderEntries();
                autoSave();
            };
            
            inputs.forEach((input, i) => {
                input.addEventListener('blur', (e) => {
                    // Only save if we're not focusing another tc field
                    setTimeout(() => {
                        if (!tcDiv.contains(document.activeElement)) {
                            saveTimecode();
                        }
                    }, 10);
                });
                
                input.addEventListener('keydown', (e) => {
                    e.stopPropagation();
                    if (e.key === 'Tab' && !e.shiftKey && i < inputs.length - 1) {
                        e.preventDefault();
                        inputs[i + 1].focus();
                        inputs[i + 1].select();
                    } else if (e.key === 'Tab' && e.shiftKey && i > 0) {
                        e.preventDefault();
                        inputs[i - 1].focus();
                        inputs[i - 1].select();
                    } else if (e.key === 'Enter') {
                        saveTimecode();
                    } else if (e.key === 'Escape') {
                        state.isEditingTimecode = false;
                        renderEntries();
                    }
                });
            });
        }

        function scrollToEntry(index) {
            if (index === null || index < 0) return;
            
            const container = document.getElementById('entriesContainer');
            const rows = container.querySelectorAll('.entry-row');
            
            if (rows[index]) {
                const row = rows[index];
                const containerHeight = container.clientHeight;
                const rowTop = row.offsetTop;
                const rowHeight = row.offsetHeight;
                
                // Position at 2/3 down the container
                const targetScroll = rowTop - (containerHeight * 0.66) + (rowHeight / 2);
                
                container.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }

        // ==================== THEMES ====================
        function getTagUsageCount(tagMeaning) {
            let count = 0;
            state.entries.forEach(entry => {
                if (entry.tags.includes(tagMeaning)) {
                    count++;
                }
            });
            return count;
        }
        
        function renderThemeEntries() {
            const container = document.getElementById('themeEntriesContainer');
            const usedKeys = Object.keys(state.themes).sort();
            
            let html = '';
            
            // Render existing themes (now editable) with usage counts
            usedKeys.forEach((key, idx) => {
                const meaning = state.themes[key];
                const usageCount = getTagUsageCount(meaning);
                html += `
                    <div class="theme-entry" data-key="${key}" data-index="${idx}">
                        <input type="text" class="theme-key-input" value="${key.toUpperCase()}" maxlength="1" data-original-key="${key}">
                        <input type="text" class="theme-meaning-input" value="${meaning}" data-key="${key}">
                        <span class="theme-usage-count" title="Times used">${usageCount}</span>
                        <button class="theme-delete-btn" data-key="${key}" title="Delete">√ó</button>
                    </div>
                `;
            });
            
            // Always add one blank entry if we have room
            if (usedKeys.length < 26) {
                html += `
                    <div class="theme-entry new-entry" data-index="${usedKeys.length}">
                        <input type="text" class="theme-key-input" maxlength="1" placeholder="Key">
                        <input type="text" class="theme-meaning-input" placeholder="Meaning">
                        <div style="width: 50px;"></div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            
            // Add handlers for ALL theme entries (existing and new)
            const allEntries = container.querySelectorAll('.theme-entry');
            
            allEntries.forEach((entry, entryIndex) => {
                const keyInput = entry.querySelector('.theme-key-input');
                const meaningInput = entry.querySelector('.theme-meaning-input');
                const deleteBtn = entry.querySelector('.theme-delete-btn');
                const isNewEntry = entry.classList.contains('new-entry');
                const originalKey = keyInput.dataset.originalKey;
                
                // Delete button handler
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const keyToDelete = deleteBtn.dataset.key;
                        delete state.themes[keyToDelete];
                        autoSave();
                        renderThemeEntries();
                        showToast(`Removed theme "${keyToDelete.toUpperCase()}"`, 'info');
                    });
                }
                
                // Key input handler
                keyInput.addEventListener('input', (e) => {
                    const newKey = e.target.value.toLowerCase();
                    if (newKey && !/^[a-z]$/.test(newKey)) {
                        e.target.value = originalKey ? originalKey.toUpperCase() : '';
                        return;
                    }
                });
                
                keyInput.addEventListener('blur', () => {
                    const newKey = keyInput.value.toLowerCase();
                    
                    if (isNewEntry) {
                        // For new entries, just validate
                        if (newKey && state.themes[newKey]) {
                            showToast(`Key "${newKey.toUpperCase()}" is already in use`, 'error');
                            keyInput.value = '';
                        }
                    } else {
                        // For existing entries, handle key change
                        if (newKey !== originalKey) {
                            if (!newKey) {
                                // Cleared the key - restore it
                                keyInput.value = originalKey.toUpperCase();
                            } else if (state.themes[newKey]) {
                                showToast(`Key "${newKey.toUpperCase()}" is already in use`, 'error');
                                keyInput.value = originalKey.toUpperCase();
                            } else {
                                // Valid new key - migrate
                                const meaning = state.themes[originalKey];
                                delete state.themes[originalKey];
                                state.themes[newKey] = meaning;
                                autoSave();
                                renderThemeEntries();
                                showToast(`Changed key from "${originalKey.toUpperCase()}" to "${newKey.toUpperCase()}"`, 'info');
                            }
                        }
                    }
                });
                
                keyInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && !e.shiftKey) {
                        // Tab goes to meaning field (natural behavior)
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        meaningInput.focus();
                    }
                    e.stopPropagation();
                });
                
                // Meaning input handler
                meaningInput.addEventListener('blur', () => {
                    if (isNewEntry) {
                        // Try to create new entry
                        const key = keyInput.value.toLowerCase();
                        const meaning = meaningInput.value.trim();
                        
                        if (key && meaning && /^[a-z]$/.test(key) && !state.themes[key]) {
                            state.themes[key] = meaning;
                            autoSave();
                            renderThemeEntries();
                            
                            // Focus the new blank entry's key field
                            setTimeout(() => {
                                const newBlank = document.querySelector('.new-entry .theme-key-input');
                                if (newBlank) newBlank.focus();
                            }, 50);
                        }
                    } else {
                        // Update existing meaning
                        const key = meaningInput.dataset.key;
                        const newMeaning = meaningInput.value.trim();
                        if (newMeaning) {
                            state.themes[key] = newMeaning;
                            autoSave();
                        }
                    }
                });
                
                meaningInput.addEventListener('keydown', (e) => {
                    if ((e.key === 'Tab' && !e.shiftKey) || e.key === 'Enter') {
                        // Tab and Enter both save and move to next key field
                        e.preventDefault();
                        meaningInput.blur();
                        setTimeout(() => {
                            const updatedContainer = document.getElementById('themeEntriesContainer');
                            const updatedEntries = updatedContainer.querySelectorAll('.theme-entry');
                            // Try to go to next entry, or stay at the last one (which will be the new blank)
                            let targetIndex = entryIndex + 1;
                            if (targetIndex >= updatedEntries.length) {
                                targetIndex = updatedEntries.length - 1;
                            }
                            const targetEntry = updatedEntries[targetIndex];
                            if (targetEntry) {
                                const targetKey = targetEntry.querySelector('.theme-key-input');
                                if (targetKey) targetKey.focus();
                            }
                        }, 60);
                    }
                    e.stopPropagation();
                });
            });
        }

        // ==================== CONTEXT MENU ====================
        function showContextMenu(x, y) {
            const menu = document.getElementById('contextMenu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('visible');
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('visible');
        }

        function handleContextMenuAction(action) {
            const index = state.contextMenuEntryIndex;
            if (index === null) return;
            
            switch (action) {
                case 'delete-renumber':
                    deleteEntry(index, true);
                    break;
                case 'delete-keep':
                    deleteEntry(index, false);
                    break;
                case 'insert-before':
                    insertEntry(index, 'before');
                    break;
                case 'insert-after':
                    insertEntry(index, 'after');
                    break;
                case 'set-reel-renumber':
                    setReelNumber(index, true);
                    break;
                case 'set-reel-keep':
                    setReelNumber(index, false);
                    break;
            }
            
            hideContextMenu();
        }

        function deleteEntry(index, renumber) {
            const removed = state.entries.splice(index, 1)[0];
            
            // If we're renumbering and removed a Cue Start or Xfade
            if (renumber && (removed.action === '1' || removed.action === '5')) {
                let cueNum = removed.cueNum;
                for (let i = index; i < state.entries.length; i++) {
                    if (state.entries[i].reel === removed.reel && 
                        (state.entries[i].action === '1' || state.entries[i].action === '5')) {
                        state.entries[i].cueNum = cueNum;
                        cueNum++;
                    }
                }
                state.currentCueInReel = cueNum - 1;
            }
            
            state.selectedEntryIndex = null;
            recalculateCueState();
            renderEntries();
            autoSave();
        }

        function insertEntry(index, position) {
            const newEntry = {
                frames: state.entries[index]?.frames || 0,
                action: null,
                tags: [],
                notes: '',
                reel: state.entries[index]?.reel || state.currentReel,
                cueNum: null,
                isNew: true
            };
            
            const insertIndex = position === 'before' ? index : index + 1;
            state.entries.splice(insertIndex, 0, newEntry);
            state.selectedEntryIndex = insertIndex;
            
            renderEntries();
            makeTimecodeEditable(insertIndex);
            
            showToast('Enter timecode, then press an action key (1-5 or 0)', 'info');
        }

        function setReelNumber(index, renumberSubsequent) {
            const newReel = prompt('Enter reel number:', state.entries[index].reel);
            if (newReel === null) return;
            
            const reelNum = parseInt(newReel);
            if (isNaN(reelNum) || reelNum < 1) {
                showToast('Invalid reel number', 'error');
                return;
            }
            
            if (renumberSubsequent) {
                const oldReel = state.entries[index].reel;
                const diff = reelNum - oldReel;
                for (let i = index; i < state.entries.length; i++) {
                    state.entries[i].reel += diff;
                }
            } else {
                state.entries[index].reel = reelNum;
            }
            
            renderEntries();
            autoSave();
        }

        function recalculateCueState() {
            state.lastCueStartIndex = null;
            
            // Walk through entries to find the current cue state
            for (let i = 0; i < state.entries.length; i++) {
                const action = state.entries[i].action;
                
                if (action === '1' || action === '6') {
                    // Cue Start or Xfade - starts a new cue
                    state.lastCueStartIndex = i;
                } else if (action === '0') {
                    // Cue End - ends the cue
                    state.lastCueStartIndex = null;
                }
                // Blank (2), Shift (3), Highlight (4), Sting (5) don't affect cue state
            }
        }

        // ==================== TOAST ====================
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ==================== AUDIO ====================
        function playErrorSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 200;
                oscillator.type = 'square';
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                // Audio not available
            }
        }

        // ==================== SAVE/LOAD/EXPORT ====================
        function getMetadata() {
            return {
                filmTitle: document.getElementById('filmTitle').value,
                director: document.getElementById('director').value,
                directorContact: document.getElementById('directorContact').value,
                composer: document.getElementById('composer').value,
                composerContact: document.getElementById('composerContact').value,
                version: document.getElementById('version').value,
                pictureDate: document.getElementById('pictureDate').value,
                sessionDate: document.getElementById('sessionDate').value,
                producers: document.getElementById('producers').value,
                producersContact: document.getElementById('producersContact').value,
                execProducers: document.getElementById('execProducers').value,
                execProducersContact: document.getElementById('execProducersContact').value
            };
        }

        function autoSave() {
            const data = {
                entries: state.entries,
                themes: state.themes,
                metadata: getMetadata(),
                currentReel: state.currentReel,
                currentCueInReel: state.currentCueInReel,
                fps: document.getElementById('fpsSelect').value,
                offset: {
                    hh: document.getElementById('offsetHH').value,
                    mm: document.getElementById('offsetMM').value,
                    ss: document.getElementById('offsetSS').value,
                    ff: document.getElementById('offsetFF').value
                }
            };
            
            localStorage.setItem('scoreSpotterSession', JSON.stringify(data));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('scoreSpotterSession');
            if (!saved) return;
            
            try {
                const data = JSON.parse(saved);
                
                state.entries = data.entries || [];
                state.themes = data.themes || {};
                state.currentReel = data.currentReel || 1;
                state.currentCueInReel = data.currentCueInReel || 0;
                
                if (data.metadata) {
                    document.getElementById('filmTitle').value = data.metadata.filmTitle || '';
                    document.getElementById('director').value = data.metadata.director || '';
                    document.getElementById('directorContact').value = data.metadata.directorContact || '';
                    document.getElementById('composer').value = data.metadata.composer || '';
                    document.getElementById('composerContact').value = data.metadata.composerContact || '';
                    document.getElementById('version').value = data.metadata.version || '';
                    document.getElementById('pictureDate').value = data.metadata.pictureDate || '';
                    document.getElementById('sessionDate').value = data.metadata.sessionDate || '';
                    document.getElementById('producers').value = data.metadata.producers || '';
                    document.getElementById('producersContact').value = data.metadata.producersContact || '';
                    document.getElementById('execProducers').value = data.metadata.execProducers || '';
                    document.getElementById('execProducersContact').value = data.metadata.execProducersContact || '';
                }
                
                if (data.fps) {
                    document.getElementById('fpsSelect').value = data.fps;
                    updateFps();
                }
                
                if (data.offset) {
                    document.getElementById('offsetHH').value = data.offset.hh || '01';
                    document.getElementById('offsetMM').value = data.offset.mm || '00';
                    document.getElementById('offsetSS').value = data.offset.ss || '00';
                    document.getElementById('offsetFF').value = data.offset.ff || '00';
                }
                
                recalculateCueState();
                renderEntries();
                renderThemeEntries();
                resetTimer();
                
            } catch (e) {
                console.error('Failed to load saved session:', e);
            }
        }

        // Generate filename in format: Score Spotting_[Film Title]_[version]_[session date]
        function generateFilename(extension) {
            const meta = getMetadata();
            const filmTitle = meta.filmTitle || 'Untitled';
            const version = meta.version ? `_${meta.version}` : '';
            const sessionDate = meta.sessionDate || new Date().toISOString().split('T')[0];
            
            // Clean filename (remove characters that might cause issues)
            const cleanTitle = filmTitle.replace(/[/\\?%*:|"<>]/g, '-');
            const cleanVersion = version.replace(/[/\\?%*:|"<>]/g, '-');
            
            return `Score Spotting_${cleanTitle}${cleanVersion}_${sessionDate}.${extension}`;
        }
        
        function downloadSession() {
            const data = {
                entries: state.entries,
                themes: state.themes,
                metadata: getMetadata(),
                currentReel: state.currentReel,
                currentCueInReel: state.currentCueInReel,
                fps: document.getElementById('fpsSelect').value,
                offset: {
                    hh: document.getElementById('offsetHH').value,
                    mm: document.getElementById('offsetMM').value,
                    ss: document.getElementById('offsetSS').value,
                    ff: document.getElementById('offsetFF').value
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = generateFilename('json');
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Session downloaded', 'info');
        }

        function loadSession(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    localStorage.setItem('scoreSpotterSession', JSON.stringify(data));
                    loadFromStorage();
                    showToast('Session loaded', 'info');
                } catch (err) {
                    showToast('Failed to load session file', 'error');
                }
            };
            reader.readAsText(file);
        }

        function exportCSV() {
            const meta = getMetadata();
            const metadata = [
                `Film Title,${meta.filmTitle}`,
                `Director,${meta.director}`,
                `Version,${meta.version}`,
                `Picture Date,${meta.pictureDate}`,
                `Producers,${meta.producers}`,
                `Exec Producers,${meta.execProducers}`,
                `Composer,${meta.composer}`,
                `FPS,${document.getElementById('fpsSelect').value}`,
                ''
            ];
            
            // Build tag summary
            const tagSummary = [];
            Object.keys(state.themes).sort().forEach(key => {
                const meaning = state.themes[key];
                const count = getTagUsageCount(meaning);
                if (count > 0) {
                    tagSummary.push({ meaning, count });
                }
            });
            
            // Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
            const headers = ['Reel', 'Cue', 'Timecode', 'Action', 'Tags', 'Notes', 'Duration', '', 'Tag Summary', 'Count'];
            
            const rows = state.entries.map((entry, index) => {
                const tc = framesToTimecode(entry.frames);
                const tagEntry = tagSummary[index] || {};
                return [
                    entry.reel,
                    getCueNumber(index),
                    tc.display,
                    getActionName(entry.action),
                    entry.tags.join('; '),
                    `"${(entry.notes || '').replace(/"/g, '""')}"`,
                    calculateDuration(index),
                    '',
                    tagEntry.meaning || '',
                    tagEntry.count || ''
                ].join(',');
            });
            
            // Add remaining tag summary entries if there are more than data rows
            for (let i = state.entries.length; i < tagSummary.length; i++) {
                rows.push(['', '', '', '', '', '', '', '', tagSummary[i].meaning, tagSummary[i].count].join(','));
            }
            
            const csv = [...metadata, headers.join(','), ...rows].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = generateFilename('csv');
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('CSV exported', 'info');
        }

        function exportXLSX() {
            const meta = getMetadata();
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Define colors - muted action colors (darker/less saturated)
            const colors = {
                titleBg: 'E8E8EC',
                headerBg: '4A7CCC',
                headerText: 'FFFFFF',
                reelBlue: 'D5E5F5',
                reelGreen: 'D6F5E5',
                cueGroupA: 'F5F5F5',
                cueGroupB: 'FFFFFF',
                // Muted action colors (50% less saturated)
                cueStart: 'DCF0E0',
                cueEnd: 'F5DDD0',
                // More muted colors for non-key actions
                shift: 'ECEEF5',
                highlight: 'F5F2E8',
                sting: 'F5F0EC',
                xfade: 'EAE5F0',
                // Text colors for key actions (to apply to timecode)
                cueStartText: '2E7D32',
                cueEndText: 'C62828',
                xfadeText: '6A1B9A',
                dimText: 'AAAAAA',
                normalText: '000000',
                borderColor: 'CCCCCC'
            };
            
            // Standard border style
            const thinBorder = {
                top: { style: 'thin', color: { rgb: colors.borderColor } },
                bottom: { style: 'thin', color: { rgb: colors.borderColor } },
                left: { style: 'thin', color: { rgb: colors.borderColor } },
                right: { style: 'thin', color: { rgb: colors.borderColor } }
            };
            
            // Styles with borders - using Courier New instead of Consolas for better compatibility
            const titleStyle = { font: { bold: true, sz: 18 }, alignment: { horizontal: 'center' } };
            const headerStyle = { 
                font: { bold: true, color: { rgb: colors.headerText } }, 
                fill: { fgColor: { rgb: colors.headerBg } },
                alignment: { horizontal: 'center' },
                border: thinBorder
            };
            const metaLabelStyle = { font: { bold: true, sz: 10 } };
            const metaValueStyle = { font: { sz: 10 } };
            
            // Build header section
            const data = [];
            
            // Row 0: Title and Session Date
            data.push([
                { v: '', s: {} },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.filmTitle || 'UNTITLED', s: titleStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.sessionDate || '', s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} },
                { v: '', s: {} }
            ]);
            
            // Rows 1-5: Metadata
            data.push([
                { v: `Director: ${meta.director || ''}`, s: metaLabelStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.version || '', s: { alignment: { horizontal: 'center' } } },
                { v: `Picture Date: ${meta.pictureDate || ''}`, s: metaValueStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: `Producers: ${meta.producers || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} },
                { v: '', s: {} }
            ]);
            data.push([
                { v: `  Contact: ${meta.directorContact || ''}`, s: metaValueStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `  Contact: ${meta.producersContact || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `Composer: ${meta.composer || ''}`, s: metaLabelStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `Exec Producers: ${meta.execProducers || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `  Contact: ${meta.composerContact || ''}`, s: metaValueStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `  Contact: ${meta.execProducersContact || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `FPS: ${document.getElementById('fpsSelect').value}`, s: metaLabelStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }
            ]);
            
            // Empty row
            data.push([]);
            
            // Build tag summary data
            const tagSummary = [];
            Object.keys(state.themes).sort().forEach(key => {
                const meaning = state.themes[key];
                const count = getTagUsageCount(meaning);
                if (count > 0) {
                    tagSummary.push({ key: key.toUpperCase(), meaning, count });
                }
            });
            
            // Header row (row 7) - Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag Summary
            data.push([
                { v: 'Reel', s: headerStyle },
                { v: 'Cue', s: headerStyle },
                { v: 'Timecode', s: headerStyle },
                { v: 'Action', s: headerStyle },
                { v: 'Tags', s: headerStyle },
                { v: 'Notes', s: headerStyle },
                { v: 'Duration', s: headerStyle },
                { v: '', s: {} },
                { v: 'Tag', s: headerStyle },
                { v: 'Count', s: headerStyle }
            ]);
            
            // Add entry data with styling
            state.entries.forEach((entry, index) => {
                const tc = framesToTimecode(entry.frames);
                const cueGroup = getCueGroupIndex(index);
                const isOddGroup = cueGroup % 2 === 1;
                const isReelOdd = entry.reel % 2 === 1;
                const isFinalDuration = entry.action === '0';  // Only Cue End is final, not Xfade
                const isKeyAction = entry.action === '1' || entry.action === '0' || entry.action === '6';
                
                // Determine row background color
                let rowBg = isOddGroup ? colors.cueGroupA : colors.cueGroupB;
                
                // Determine action-specific color (muted)
                let actionBg = rowBg;
                if (entry.action === '1') actionBg = colors.cueStart;
                else if (entry.action === '0') actionBg = colors.cueEnd;
                else if (entry.action === '3') actionBg = colors.shift;
                else if (entry.action === '4') actionBg = colors.highlight;
                else if (entry.action === '5') actionBg = colors.sting;
                else if (entry.action === '6') actionBg = colors.xfade;
                
                // Determine timecode text color for key actions
                let tcTextColor = colors.normalText;
                if (entry.action === '1') tcTextColor = colors.cueStartText;
                else if (entry.action === '0') tcTextColor = colors.cueEndText;
                else if (entry.action === '6') tcTextColor = colors.xfadeText;
                
                // Reel indicator color
                const reelBg = isReelOdd ? colors.reelBlue : colors.reelGreen;
                
                const rowStyle = { fill: { fgColor: { rgb: rowBg } }, border: thinBorder };
                const actionStyle = { fill: { fgColor: { rgb: actionBg } }, alignment: { horizontal: 'center' }, border: thinBorder };
                const reelStyle = { fill: { fgColor: { rgb: reelBg } }, alignment: { horizontal: 'center' }, font: { bold: true }, border: thinBorder };
                
                // Timecode style - colored for key actions (Cue Start, Cue End, Xfade)
                const tcStyle = isKeyAction 
                    ? { font: { name: 'Courier New', bold: true, color: { rgb: tcTextColor } }, fill: { fgColor: { rgb: actionBg } }, border: thinBorder }
                    : { font: { name: 'Courier New' }, fill: { fgColor: { rgb: rowBg } }, border: thinBorder };
                
                // Duration style - final durations are bold/dark, non-final are light gray
                const durStyle = isFinalDuration 
                    ? { font: { name: 'Courier New', bold: true, color: { rgb: colors.normalText } }, fill: { fgColor: { rgb: rowBg } }, alignment: { horizontal: 'right' }, border: thinBorder }
                    : { font: { name: 'Courier New', color: { rgb: colors.dimText } }, fill: { fgColor: { rgb: rowBg } }, alignment: { horizontal: 'right' }, border: thinBorder };
                
                // Tag summary for this row (if applicable)
                const tagSummaryEntry = tagSummary[index];
                const tagCell = tagSummaryEntry ? { v: tagSummaryEntry.meaning, s: { border: thinBorder } } : { v: '', s: {} };
                const countCell = tagSummaryEntry ? { v: tagSummaryEntry.count, s: { alignment: { horizontal: 'center' }, border: thinBorder } } : { v: '', s: {} };
                
                // Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
                data.push([
                    { v: entry.reel, s: reelStyle },
                    { v: getCueNumber(index), s: { ...rowStyle, font: { bold: true, color: { rgb: '4A7CCC' } }, border: thinBorder } },
                    { v: tc.display, s: tcStyle },
                    { v: getActionName(entry.action), s: actionStyle },
                    { v: entry.tags.join('; '), s: rowStyle },
                    { v: entry.notes || '', s: rowStyle },
                    { v: calculateDuration(index), s: durStyle },
                    { v: '', s: {} },
                    tagCell,
                    countCell
                ]);
            });
            
            // If there are more tag summary entries than data rows, add them
            for (let i = state.entries.length; i < tagSummary.length; i++) {
                const tagSummaryEntry = tagSummary[i];
                const row = [
                    { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                    { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                    { v: tagSummaryEntry.meaning, s: { border: thinBorder } },
                    { v: tagSummaryEntry.count, s: { alignment: { horizontal: 'center' }, border: thinBorder } }
                ];
                data.push(row);
            }
            
            // Create worksheet from styled data
            const ws = XLSX.utils.aoa_to_sheet(data.map(row => row.map ? row.map(cell => cell.v !== undefined ? cell.v : cell) : row));
            
            // Apply styles to cells
            data.forEach((row, r) => {
                if (!row.map) return;
                row.forEach((cell, c) => {
                    if (cell.s && Object.keys(cell.s).length > 0) {
                        const cellRef = XLSX.utils.encode_cell({ r, c });
                        if (ws[cellRef]) {
                            ws[cellRef].s = cell.s;
                        }
                    }
                });
            });
            
            // Set column widths - Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
            ws['!cols'] = [
                { wch: 5 },   // Reel (narrow, just number)
                { wch: 8 },   // Cue
                { wch: 14 },  // Timecode
                { wch: 12 },  // Action
                { wch: 30 },  // Tags
                { wch: 50 },  // Notes
                { wch: 14 },  // Duration
                { wch: 3 },   // Gap
                { wch: 20 },  // Tag summary - meaning
                { wch: 8 }    // Tag summary - count
            ];
            
            // Merge cells for title
            ws['!merges'] = [
                { s: { r: 0, c: 3 }, e: { r: 0, c: 5 } }
            ];
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, 'Spotting Notes');
            
            // Generate and download
            XLSX.writeFile(wb, generateFilename('xlsx'));
            
            showToast('Excel file exported with formatting', 'info');
        }

        // ==================== NEW SESSION / CLEAR ====================
        function showNewSessionModal() {
            document.getElementById('newSessionModal').classList.add('visible');
        }

        function hideNewSessionModal() {
            document.getElementById('newSessionModal').classList.remove('visible');
        }

        function clearSession() {
            // Clear state
            state.entries = [];
            state.themes = {};
            state.currentReel = 1;
            state.currentCueInReel = 0;
            state.selectedEntryIndex = null;
            state.lastCueStartIndex = null;
            state.actionHistory = [];
            
            // Clear metadata inputs
            document.getElementById('filmTitle').value = '';
            document.getElementById('director').value = '';
            document.getElementById('directorContact').value = '';
            document.getElementById('composer').value = '';
            document.getElementById('composerContact').value = '';
            document.getElementById('version').value = '';
            document.getElementById('pictureDate').value = '';
            document.getElementById('sessionDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('producers').value = '';
            document.getElementById('producersContact').value = '';
            document.getElementById('execProducers').value = '';
            document.getElementById('execProducersContact').value = '';
            
            // Reset timer settings
            document.getElementById('fpsSelect').value = '24';
            document.getElementById('offsetHH').value = '01';
            document.getElementById('offsetMM').value = '00';
            document.getElementById('offsetSS').value = '00';
            document.getElementById('offsetFF').value = '00';
            
            // Clear localStorage
            localStorage.removeItem('scoreSpotterSession');
            
            // Update display
            updateFps(false);
            resetTimer();
            renderEntries();
            renderThemeEntries();
            
            hideNewSessionModal();
            showToast('Session cleared - ready for new project', 'info');
        }
        
        function clearSessionKeepInfo() {
            // Clear only entries, keep project info and themes
            state.entries = [];
            state.currentReel = 1;
            state.currentCueInReel = 0;
            state.selectedEntryIndex = null;
            state.lastCueStartIndex = null;
            state.actionHistory = [];
            
            // Update session date to today
            document.getElementById('sessionDate').value = new Date().toISOString().split('T')[0];
            
            // Reset timer to offset
            resetTimer();
            
            // Update display
            renderEntries();
            renderThemeEntries();
            autoSave();
            
            hideNewSessionModal();
            showToast('Cues cleared - project info and tags kept', 'info');
        }

        // ==================== FPS ====================
        function updateFps(preserveTimecode = true) {
            const fpsValue = document.getElementById('fpsSelect').value;
            const oldFps = state.timer.fps;
            const newFps = getFpsValue(fpsValue);
            const wasDropFrame = state.timer.isDropFrame;
            const isNowDropFrame = isDropFrame(fpsValue);
            
            // If preserving timecode, convert current time to new fps
            if (preserveTimecode && (oldFps !== newFps || wasDropFrame !== isNowDropFrame)) {
                // Get current timecode components (HH:MM:SS:FF)
                const tc = framesToTimecode(state.timer.currentFrames);
                
                // Update fps settings first
                state.timer.fps = newFps;
                state.timer.isDropFrame = isNowDropFrame;
                
                // Calculate proportional frame (keep HH:MM:SS, scale FF)
                const oldMaxFrames = Math.floor(oldFps);
                const newMaxFrames = Math.floor(newFps);
                let newFrame = Math.round(tc.ff / oldMaxFrames * newMaxFrames);
                
                // Clamp to valid range
                if (newFrame >= newMaxFrames) newFrame = newMaxFrames - 1;
                if (newFrame < 0) newFrame = 0;
                
                // Convert back to frames with new fps (using same HH:MM:SS, new FF)
                state.timer.currentFrames = timecodeToFrames(tc.hh, tc.mm, tc.ss, newFrame);
                
                // Also update offset
                const offsetTC = framesToTimecodeWithFps(state.timer.offsetFrames, oldFps, wasDropFrame);
                let newOffsetFrame = Math.round(offsetTC.ff / oldMaxFrames * newMaxFrames);
                if (newOffsetFrame >= newMaxFrames) newOffsetFrame = newMaxFrames - 1;
                if (newOffsetFrame < 0) newOffsetFrame = 0;
                
                document.getElementById('offsetFF').value = String(newOffsetFrame).padStart(2, '0');
                state.timer.offsetFrames = timecodeToFrames(offsetTC.hh, offsetTC.mm, offsetTC.ss, newOffsetFrame);
            } else {
                state.timer.fps = newFps;
                state.timer.isDropFrame = isNowDropFrame;
            }
            
            const sep = state.timer.isDropFrame ? ';' : ':';
            document.getElementById('offsetFrameSep').textContent = sep;
            document.getElementById('jumpFrameSep').textContent = sep;
            
            // Update FPS display in header
            document.getElementById('fpsDisplay').textContent = `FPS: ${fpsValue.replace('ndf', ' NDF').replace('df', ' DF')}`;
            
            updateTimerDisplay();
        }
        
        // Helper to convert frames to timecode with specific fps (for fps switching)
        function framesToTimecodeWithFps(totalFrames, fps, dropFrame) {
            if (dropFrame && (Math.abs(fps - 29.97) < 0.01 || Math.abs(fps - 59.94) < 0.01)) {
                const dropFrames = Math.abs(fps - 29.97) < 0.01 ? 2 : 4;
                const framesPerMin = Math.round(fps * 60);
                const framesPer10Min = Math.round(fps * 60 * 10);
                
                let frameNumber = totalFrames;
                const d = Math.floor(frameNumber / framesPer10Min);
                const m = frameNumber % framesPer10Min;
                
                if (m < dropFrames) {
                    frameNumber = frameNumber + dropFrames * d;
                } else {
                    frameNumber = frameNumber + dropFrames * (d + Math.floor((m - dropFrames) / (framesPerMin - dropFrames)));
                }
                
                const maxFrames = Math.ceil(fps);
                const ff = frameNumber % maxFrames;
                const ss = Math.floor(frameNumber / maxFrames) % 60;
                const mm = Math.floor(frameNumber / (maxFrames * 60)) % 60;
                const hh = Math.floor(frameNumber / (maxFrames * 60 * 60));
                
                return { hh, mm, ss, ff };
            } else {
                const maxFrames = Math.round(fps);
                const ff = totalFrames % maxFrames;
                const totalSeconds = Math.floor(totalFrames / maxFrames);
                const ss = totalSeconds % 60;
                const mm = Math.floor(totalSeconds / 60) % 60;
                const hh = Math.floor(totalSeconds / 3600);
                
                return { hh, mm, ss, ff };
            }
        }

        // ==================== DRAGGABLE TIMER ====================
        function makeTimerDraggable() {
            const timer = document.getElementById('floatingTimer');
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            timer.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = timer.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                
                timer.style.transform = 'none';
                timer.style.left = startLeft + 'px';
                timer.style.top = startTop + 'px';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                timer.style.left = (startLeft + dx) + 'px';
                timer.style.top = (startTop + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // ==================== KEYBOARD HANDLING ====================
        function handleKeydown(e) {
            // Ignore if editing notes or timecode
            if (state.isEditingNotes || state.isEditingTimecode) return;
            
            // Ignore if typing in most inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // But allow some keys to work in the timer inputs
                if (!e.target.closest('.floating-timer') && !e.target.closest('.theme-entry')) {
                    return;
                }
                // Only allow timer/theme inputs if not the action keys
                if (!['ArrowRight', 'ArrowLeft'].includes(e.key)) {
                    return;
                }
            }
            
            // Timer controls
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                toggleTimer();
                return;
            }
            
            if (e.key === 'ArrowLeft' && e.shiftKey) {
                e.preventDefault();
                resetTimer();
                return;
            }
            
            // Action keys: 1=Cue Start, 2=Blank, 3=Shift, 4=Highlight, 5=Sting, 6=Xfade
            if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                e.preventDefault();
                
                if (state.timer.isPlaying) {
                    addEntry(e.key);
                } else if (state.selectedEntryIndex !== null) {
                    // Change action of selected entry
                    const entry = state.entries[state.selectedEntryIndex];
                    const wasStart = entry.action === '1';
                    const wasXfade = entry.action === '6';
                    const hadCueNum = wasStart || wasXfade;
                    
                    entry.action = e.key;
                    
                    // If changing to Cue Start or Xfade and didn't have a cue number
                    if ((e.key === '1' || e.key === '6') && !hadCueNum) {
                        state.currentCueInReel++;
                        entry.cueNum = state.currentCueInReel;
                    } 
                    // If changing away from Cue Start/Xfade to something else
                    else if (hadCueNum && e.key !== '1' && e.key !== '6') {
                        entry.cueNum = null;
                    }
                    
                    recalculateCueState();
                    renderEntries();
                    autoSave();
                }
                return;
            }
            
            // Escape = Cue End (stored as '0')
            if (e.key === 'Escape') {
                e.preventDefault();
                
                if (state.timer.isPlaying) {
                    addEntry('0');
                } else if (state.selectedEntryIndex !== null) {
                    // Change selected entry to Cue End
                    const entry = state.entries[state.selectedEntryIndex];
                    const hadCueNum = entry.action === '1' || entry.action === '5';
                    
                    entry.action = '0';
                    if (hadCueNum) {
                        entry.cueNum = null;
                    }
                    
                    recalculateCueState();
                    renderEntries();
                    autoSave();
                }
                return;
            }
            
            // Theme keys (A-Z)
            if (/^[a-zA-Z]$/.test(e.key) && !e.ctrlKey && !e.metaKey) {
                if (state.selectedEntryIndex !== null || state.timer.isPlaying) {
                    e.preventDefault();
                    addTagToEntry(e.key);
                }
                return;
            }
            
            // Next reel
            if (e.key === '\\') {
                e.preventDefault();
                nextReel();
                return;
            }
            
            // Delete last action
            if (e.key === 'Delete' || (e.key === 'Backspace' && !e.target.closest('input'))) {
                e.preventDefault();
                removeLastAction();
                return;
            }
            
            // Backtick to deselect
            if (e.key === '`') {
                e.preventDefault();
                state.selectedEntryIndex = null;
                renderEntries();
                return;
            }
            
            // Minus key - subtract reaction time from last entry
            if (e.key === '-') {
                e.preventDefault();
                subtractReactionTime();
                return;
            }
        }
        
        // Subtract reaction time from the most recent entry
        function subtractReactionTime() {
            if (state.entries.length === 0) {
                showToast('No entries to adjust', 'error');
                return;
            }
            
            const reactionSeconds = parseFloat(document.getElementById('reactionTime').value) || 2.0;
            const framesToSubtract = Math.round(reactionSeconds * state.timer.fps);
            
            // Get the most recent entry (or selected entry)
            const targetIndex = state.selectedEntryIndex !== null ? state.selectedEntryIndex : state.entries.length - 1;
            const entry = state.entries[targetIndex];
            
            const oldFrames = entry.frames;
            const newFrames = Math.max(0, oldFrames - framesToSubtract);
            entry.frames = newFrames;
            
            // Re-sort entries if timecode changed position
            state.entries.sort((a, b) => a.frames - b.frames);
            
            // Find the new index of the entry we just modified
            const newIndex = state.entries.findIndex(e => e === entry);
            state.selectedEntryIndex = newIndex;
            
            recalculateCueState();
            renderEntries();
            autoSave();
            
            const oldTC = framesToTimecode(oldFrames).display;
            const newTC = framesToTimecode(newFrames).display;
            showToast(`Adjusted ${oldTC} ‚Üí ${newTC} (-${reactionSeconds}s)`, 'info');
        }

        // ==================== INIT ====================
        function init() {
            // Set today's date as default session date
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('sessionDate').value = today;
            
            // Initialize timer
            updateFps(false);
            resetTimer();
            
            // Load saved session
            loadFromStorage();
            
            // Render
            renderEntries();
            renderThemeEntries();
            
            // Make timer draggable
            makeTimerDraggable();
            
            // Event listeners
            document.addEventListener('keydown', handleKeydown);
            
            document.getElementById('fpsSelect').addEventListener('change', () => {
                updateFps();
                autoSave();
            });
            
            document.getElementById('jumpBtn').addEventListener('click', jumpToTime);
            
            // Offset field handlers
            ['offsetHH', 'offsetMM', 'offsetSS', 'offsetFF'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    resetTimer();
                    autoSave();
                });
            });
            
            // Metadata auto-save
            document.querySelectorAll('.header-input, .film-title-input').forEach(input => {
                input.addEventListener('change', autoSave);
            });
            
            // Save/Load/Export buttons
            document.getElementById('downloadSessionBtn').addEventListener('click', downloadSession);
            document.getElementById('loadSessionBtn').addEventListener('click', () => {
                document.getElementById('loadSessionInput').click();
            });
            document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadSession(e.target.files[0]);
                }
            });
            document.getElementById('exportCsvBtn').addEventListener('click', exportCSV);
            document.getElementById('exportXlsxBtn').addEventListener('click', exportXLSX);
            
            // New session modal
            document.getElementById('newSessionBtn').addEventListener('click', showNewSessionModal);
            document.getElementById('modalCancelBtn').addEventListener('click', hideNewSessionModal);
            document.getElementById('modalDownloadBtn').addEventListener('click', () => {
                downloadSession();
                clearSession();
            });
            document.getElementById('modalExportBtn').addEventListener('click', () => {
                exportXLSX();
                clearSession();
            });
            document.getElementById('modalClearBtn').addEventListener('click', clearSession);
            document.getElementById('modalKeepInfoBtn').addEventListener('click', clearSessionKeepInfo);
            
            // Close modal on overlay click
            document.getElementById('newSessionModal').addEventListener('click', (e) => {
                if (e.target.id === 'newSessionModal') {
                    hideNewSessionModal();
                }
            });
            
            // Context menu
            document.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    handleContextMenuAction(item.dataset.action);
                });
            });
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.context-menu')) {
                    hideContextMenu();
                }
            });
            
            // Jump field tab navigation
            ['jumpHH', 'jumpMM', 'jumpSS', 'jumpFF'].forEach((id, index, arr) => {
                document.getElementById(id).addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && !e.shiftKey && index < arr.length - 1) {
                        e.preventDefault();
                        document.getElementById(arr[index + 1]).focus();
                    }
                    if (e.key === 'Enter') {
                        jumpToTime();
                    }
                });
            });
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
